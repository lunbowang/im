// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const createMessage = `-- name: CreateMessage :one
insert into messages (notify_type, msg_type, msg_content, msg_extend, file_id, account_id, rly_msg_id, relation_id)
values ($1, $2, $3, $4, $5, $6, $7, $8)
returning id, msg_content, msg_extend, file_id, create_at
`

type CreateMessageParams struct {
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RlyMsgID   sql.NullInt64
	RelationID int64
}

type CreateMessageRow struct {
	ID         int64
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	CreateAt   time.Time
}

func (q *Queries) CreateMessage(ctx context.Context, arg *CreateMessageParams) (*CreateMessageRow, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.NotifyType,
		arg.MsgType,
		arg.MsgContent,
		arg.MsgExtend,
		arg.FileID,
		arg.AccountID,
		arg.RlyMsgID,
		arg.RelationID,
	)
	var i CreateMessageRow
	err := row.Scan(
		&i.ID,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.CreateAt,
	)
	return &i, err
}

const getMessageByID = `-- name: GetMessageByID :one
select id, notify_type, msg_type, msg_content, msg_extend, file_id, account_id,
       rly_msg_id, relation_id, create_at, is_revoke, is_top, is_pin, pin_time, read_ids
from messages
where id = $1
limit 1
`

type GetMessageByIDRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RlyMsgID   sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    []int64
}

func (q *Queries) GetMessageByID(ctx context.Context, id int64) (*GetMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.NotifyType,
		&i.MsgType,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.AccountID,
		&i.RlyMsgID,
		&i.RelationID,
		&i.CreateAt,
		&i.IsRevoke,
		&i.IsTop,
		&i.IsPin,
		&i.PinTime,
		&i.ReadIds,
	)
	return &i, err
}

const getMsgsByContent = `-- name: GetMsgsByContent :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       count(*) over () as total
from messages m1
     join settings s on m1.relation_id = s.relation_id and s.account_id = $1
where (not is_revoke)
    and m1.msg_content_tsy @@ plainto_tsquery($4::varchar)
order by m1.create_at desc
limit $2 offset $3
`

type GetMsgsByContentParams struct {
	AccountID int64
	Limit     int32
	Offset    int32
	Content   string
}

type GetMsgsByContentRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	Total      int64
}

func (q *Queries) GetMsgsByContent(ctx context.Context, arg *GetMsgsByContentParams) ([]*GetMsgsByContentRow, error) {
	rows, err := q.db.Query(ctx, getMsgsByContent,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
		arg.Content,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMsgsByContentRow{}
	for rows.Next() {
		var i GetMsgsByContentRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RelationID,
			&i.CreateAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMsgsByContentAndRelation = `-- name: GetMsgsByContentAndRelation :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       count(*) over () as total
from messages m1
    join settings s on m1.relation_id = $1 and m1.relation_id = s.relation_id and s.account_id = $2
where (not m1.is_revoke)
    and m1.msg_content_tsy @@ plainto_tsquery($5::varchar)
order by m1.create_at desc
limit $3 offset $4
`

type GetMsgsByContentAndRelationParams struct {
	RelationID int64
	AccountID  int64
	Limit      int32
	Offset     int32
	Content    string
}

type GetMsgsByContentAndRelationRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	Total      int64
}

func (q *Queries) GetMsgsByContentAndRelation(ctx context.Context, arg *GetMsgsByContentAndRelationParams) ([]*GetMsgsByContentAndRelationRow, error) {
	rows, err := q.db.Query(ctx, getMsgsByContentAndRelation,
		arg.RelationID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
		arg.Content,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMsgsByContentAndRelationRow{}
	for rows.Next() {
		var i GetMsgsByContentAndRelationRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RelationID,
			&i.CreateAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMsgsByRelationIDAndTime = `-- name: GetMsgsByRelationIDAndTime :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.rly_msg_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       count(*) over () as total,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = $1) as reply_count
from messages m1
where m1.relation_id = $1
    and m1.create_at < $2
order by m1.create_at
limit $3 offset $4
`

type GetMsgsByRelationIDAndTimeParams struct {
	RelationID int64
	CreateAt   time.Time
	Limit      int32
	Offset     int32
}

type GetMsgsByRelationIDAndTimeRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RlyMsgID   sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    []int64
	Total      int64
	ReplyCount int64
}

func (q *Queries) GetMsgsByRelationIDAndTime(ctx context.Context, arg *GetMsgsByRelationIDAndTimeParams) ([]*GetMsgsByRelationIDAndTimeRow, error) {
	rows, err := q.db.Query(ctx, getMsgsByRelationIDAndTime,
		arg.RelationID,
		arg.CreateAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMsgsByRelationIDAndTimeRow{}
	for rows.Next() {
		var i GetMsgsByRelationIDAndTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RlyMsgID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.Total,
			&i.ReplyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPinMsgsByRelationID = `-- name: GetPinMsgsByRelationID :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = $1) as reply_count,
       count(*) over () as total
from messages m1
where m1.relation_id = $1 and m1.is_pin = true
order by m1.pin_time desc
limit $2 offset $3
`

type GetPinMsgsByRelationIDParams struct {
	RelationID int64
	Limit      int32
	Offset     int32
}

type GetPinMsgsByRelationIDRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    []int64
	ReplyCount int64
	Total      int64
}

func (q *Queries) GetPinMsgsByRelationID(ctx context.Context, arg *GetPinMsgsByRelationIDParams) ([]*GetPinMsgsByRelationIDRow, error) {
	rows, err := q.db.Query(ctx, getPinMsgsByRelationID, arg.RelationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPinMsgsByRelationIDRow{}
	for rows.Next() {
		var i GetPinMsgsByRelationIDRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.ReplyCount,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRlyMsgsInfoByMsgID = `-- name: GetRlyMsgsInfoByMsgID :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = $1) as reply_count,
       count(*) over () as total
from messages m1
where m1.relation_id = $1 and m1.rly_msg_id = $4::bigint
order by m1.create_at
limit $2 offset $3
`

type GetRlyMsgsInfoByMsgIDParams struct {
	RelationID int64
	Limit      int32
	Offset     int32
	RlyMsgID   int64
}

type GetRlyMsgsInfoByMsgIDRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    []int64
	ReplyCount int64
	Total      int64
}

func (q *Queries) GetRlyMsgsInfoByMsgID(ctx context.Context, arg *GetRlyMsgsInfoByMsgIDParams) ([]*GetRlyMsgsInfoByMsgIDRow, error) {
	rows, err := q.db.Query(ctx, getRlyMsgsInfoByMsgID,
		arg.RelationID,
		arg.Limit,
		arg.Offset,
		arg.RlyMsgID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRlyMsgsInfoByMsgIDRow{}
	for rows.Next() {
		var i GetRlyMsgsInfoByMsgIDRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.ReplyCount,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopMsgByRelationID = `-- name: GetTopMsgByRelationID :one
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = $1) as reply_count,
       count(*) over () as total
from messages m1
where m1.relation_id = $1 and m1.is_top = true
limit 1
`

type GetTopMsgByRelationIDRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    []int64
	ReplyCount int64
	Total      int64
}

func (q *Queries) GetTopMsgByRelationID(ctx context.Context, relationID int64) (*GetTopMsgByRelationIDRow, error) {
	row := q.db.QueryRow(ctx, getTopMsgByRelationID, relationID)
	var i GetTopMsgByRelationIDRow
	err := row.Scan(
		&i.ID,
		&i.NotifyType,
		&i.MsgType,
		&i.MsgContent,
		&i.MsgExtend,
		&i.FileID,
		&i.AccountID,
		&i.RelationID,
		&i.CreateAt,
		&i.IsRevoke,
		&i.IsTop,
		&i.IsPin,
		&i.PinTime,
		&i.ReadIds,
		&i.ReplyCount,
		&i.Total,
	)
	return &i, err
}

const offerMsgsByAccountIDAndTime = `-- name: OfferMsgsByAccountIDAndTime :many
select m1.id,
       m1.notify_type,
       m1.msg_type,
       m1.msg_content,
       m1.msg_extend,
       m1.file_id,
       m1.account_id,
       m1.rly_msg_id,
       m1.relation_id,
       m1.create_at,
       m1.is_revoke,
       m1.is_top,
       m1.is_pin,
       m1.pin_time,
       m1.read_ids,
       count(*) over () as total,
       (select count(id) from messages where rly_msg_id = m1.id and messages.relation_id = m1.relation_id) as reply_count,
       (m1.account_id = $4::bigint or $4::bigint = any (m1.read_ids))::boolean as has_read
from messages m1
        join settings s on m1.relation_id = s.relation_id and s.account_id = $4::bigint
where m1.create_at > $1
limit $2 offset $3
`

type OfferMsgsByAccountIDAndTimeParams struct {
	CreateAt  time.Time
	Limit     int32
	Offset    int32
	Accountid int64
}

type OfferMsgsByAccountIDAndTimeRow struct {
	ID         int64
	NotifyType Msgnotifytype
	MsgType    string
	MsgContent string
	MsgExtend  pgtype.JSON
	FileID     sql.NullInt64
	AccountID  sql.NullInt64
	RlyMsgID   sql.NullInt64
	RelationID int64
	CreateAt   time.Time
	IsRevoke   bool
	IsTop      bool
	IsPin      bool
	PinTime    time.Time
	ReadIds    []int64
	Total      int64
	ReplyCount int64
	HasRead    bool
}

func (q *Queries) OfferMsgsByAccountIDAndTime(ctx context.Context, arg *OfferMsgsByAccountIDAndTimeParams) ([]*OfferMsgsByAccountIDAndTimeRow, error) {
	rows, err := q.db.Query(ctx, offerMsgsByAccountIDAndTime,
		arg.CreateAt,
		arg.Limit,
		arg.Offset,
		arg.Accountid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*OfferMsgsByAccountIDAndTimeRow{}
	for rows.Next() {
		var i OfferMsgsByAccountIDAndTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.NotifyType,
			&i.MsgType,
			&i.MsgContent,
			&i.MsgExtend,
			&i.FileID,
			&i.AccountID,
			&i.RlyMsgID,
			&i.RelationID,
			&i.CreateAt,
			&i.IsRevoke,
			&i.IsTop,
			&i.IsPin,
			&i.PinTime,
			&i.ReadIds,
			&i.Total,
			&i.ReplyCount,
			&i.HasRead,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMsgPin = `-- name: UpdateMsgPin :exec
update messages
set is_pin = $2
where id = $1
`

type UpdateMsgPinParams struct {
	ID    int64
	IsPin bool
}

func (q *Queries) UpdateMsgPin(ctx context.Context, arg *UpdateMsgPinParams) error {
	_, err := q.db.Exec(ctx, updateMsgPin, arg.ID, arg.IsPin)
	return err
}

const updateMsgReads = `-- name: UpdateMsgReads :many
update messages m
set read_ids = array_append(read_ids, $2::bigint)
where id = any ($3::bigint[])
and $2::bigint != ANY (read_ids)
and relation_id = $1
returning id, account_id::bigint
`

type UpdateMsgReadsParams struct {
	RelationID int64
	Accountid  int64
	Msgids     []int64
}

type UpdateMsgReadsRow struct {
	ID        int64
	AccountID int64
}

func (q *Queries) UpdateMsgReads(ctx context.Context, arg *UpdateMsgReadsParams) ([]*UpdateMsgReadsRow, error) {
	rows, err := q.db.Query(ctx, updateMsgReads, arg.RelationID, arg.Accountid, arg.Msgids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UpdateMsgReadsRow{}
	for rows.Next() {
		var i UpdateMsgReadsRow
		if err := rows.Scan(&i.ID, &i.AccountID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMsgRevoke = `-- name: UpdateMsgRevoke :exec
update messages
set is_revoke = $2
where id = $1
`

type UpdateMsgRevokeParams struct {
	ID       int64
	IsRevoke bool
}

func (q *Queries) UpdateMsgRevoke(ctx context.Context, arg *UpdateMsgRevokeParams) error {
	_, err := q.db.Exec(ctx, updateMsgRevoke, arg.ID, arg.IsRevoke)
	return err
}

const updateMsgTop = `-- name: UpdateMsgTop :exec
update messages
set is_top = $2
where id = $1
`

type UpdateMsgTopParams struct {
	ID    int64
	IsTop bool
}

func (q *Queries) UpdateMsgTop(ctx context.Context, arg *UpdateMsgTopParams) error {
	_, err := q.db.Exec(ctx, updateMsgTop, arg.ID, arg.IsTop)
	return err
}
