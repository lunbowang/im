// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: relation.sql

package db

import (
	"context"
	"database/sql"
)

const createFriendRelation = `-- name: CreateFriendRelation :one
insert into relations (relation_type, friend_type)
values ('friend', ROW ($1::bigint, $2::bigint))
returning id
`

type CreateFriendRelationParams struct {
	Account1ID int64
	Account2ID int64
}

func (q *Queries) CreateFriendRelation(ctx context.Context, arg *CreateFriendRelationParams) (int64, error) {
	row := q.db.QueryRow(ctx, createFriendRelation, arg.Account1ID, arg.Account2ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createGroupRelation = `-- name: CreateGroupRelation :one
insert into relations (relation_type, group_type)
values ('group', ROW ($1::varchar(50), $2::varchar(255), $3::varchar(255)))
returning id
`

type CreateGroupRelationParams struct {
	Name        string
	Description string
	Avatar      string
}

func (q *Queries) CreateGroupRelation(ctx context.Context, arg *CreateGroupRelationParams) (int64, error) {
	row := q.db.QueryRow(ctx, createGroupRelation, arg.Name, arg.Description, arg.Avatar)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteFriendRelationsByAccountID = `-- name: DeleteFriendRelationsByAccountID :many
delete
from relations
where relation_type = 'friend'
 and ((friend_type).account1_id = $1::bigint or (friend_type).account2_id = $1::bigint)
returning id
`

func (q *Queries) DeleteFriendRelationsByAccountID(ctx context.Context, account1ID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, deleteFriendRelationsByAccountID, account1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteRelation = `-- name: DeleteRelation :exec
delete
from relations
where id = $1
`

func (q *Queries) DeleteRelation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRelation, id)
	return err
}

const existsFriendRelation = `-- name: ExistsFriendRelation :one
select exists(select 1
              from relations
              where relation_type = 'friend'
               and (friend_type).account1_id = $1::bigint
               and (friend_type).account2_id = $2::bigint)
`

type ExistsFriendRelationParams struct {
	Account1ID int64
	Account2ID int64
}

func (q *Queries) ExistsFriendRelation(ctx context.Context, arg *ExistsFriendRelationParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsFriendRelation, arg.Account1ID, arg.Account2ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllGroupRelation = `-- name: GetAllGroupRelation :many
select id
from relations
where relation_type = 'group'
    and friend_type is null
`

func (q *Queries) GetAllGroupRelation(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllGroupRelation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelationIDs = `-- name: GetAllRelationIDs :many
select id
from relations
`

func (q *Queries) GetAllRelationIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllRelationIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelationOnRelation = `-- name: GetAllRelationOnRelation :many
select id, relation_type, group_type, friend_type, create_at
from relations
`

func (q *Queries) GetAllRelationOnRelation(ctx context.Context) ([]*Relation, error) {
	rows, err := q.db.Query(ctx, getAllRelationOnRelation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Relation{}
	for rows.Next() {
		var i Relation
		if err := rows.Scan(
			&i.ID,
			&i.RelationType,
			&i.GroupType,
			&i.FriendType,
			&i.CreateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendRelationByID = `-- name: GetFriendRelationByID :one
select (friend_type).account1_id as account1_id,
       (friend_type).account2_id as account2_id,
       create_at
from relations
where relation_type = 'friend'
    and id = $1
`

type GetFriendRelationByIDRow struct {
	Account1ID interface{}
	Account2ID interface{}
	CreateAt   sql.NullTime
}

func (q *Queries) GetFriendRelationByID(ctx context.Context, id int64) (*GetFriendRelationByIDRow, error) {
	row := q.db.QueryRow(ctx, getFriendRelationByID, id)
	var i GetFriendRelationByIDRow
	err := row.Scan(&i.Account1ID, &i.Account2ID, &i.CreateAt)
	return &i, err
}

const getGroupRelationByID = `-- name: GetGroupRelationByID :one
select id,
        relation_type,
        (group_type).name::varchar as name,
        (group_type).description::varchar as description,
        (group_type).avatar::varchar as avatar,
        create_at
from relations
where relation_type = 'group'
 and id = $1
`

type GetGroupRelationByIDRow struct {
	ID           int64
	RelationType Relationtype
	Name         string
	Description  string
	Avatar       string
	CreateAt     sql.NullTime
}

func (q *Queries) GetGroupRelationByID(ctx context.Context, id int64) (*GetGroupRelationByIDRow, error) {
	row := q.db.QueryRow(ctx, getGroupRelationByID, id)
	var i GetGroupRelationByIDRow
	err := row.Scan(
		&i.ID,
		&i.RelationType,
		&i.Name,
		&i.Description,
		&i.Avatar,
		&i.CreateAt,
	)
	return &i, err
}

const getRelationIDByAccountID = `-- name: GetRelationIDByAccountID :one
select id
from relations
where (friend_type).account1_id = $1::bigint
  and (friend_type).account2_id = $1::bigint
`

func (q *Queries) GetRelationIDByAccountID(ctx context.Context, accountID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getRelationIDByAccountID, accountID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateGroupRelation = `-- name: UpdateGroupRelation :exec
update relations
set group_type = (ROW ($1::varchar(50), $2::varchar(255), $3::varchar(255)))
where relation_type = 'group'
 and id = $4
`

type UpdateGroupRelationParams struct {
	Name        string
	Description string
	Avatar      string
	ID          int64
}

func (q *Queries) UpdateGroupRelation(ctx context.Context, arg *UpdateGroupRelationParams) error {
	_, err := q.db.Exec(ctx, updateGroupRelation,
		arg.Name,
		arg.Description,
		arg.Avatar,
		arg.ID,
	)
	return err
}
