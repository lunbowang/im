// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: setting.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

type CreateManySettingParams struct {
	AccountID  int64
	RelationID int64
	NickName   string
}

const createSetting = `-- name: CreateSetting :exec
insert into settings (account_id, relation_id, nick_name, is_leader, is_self)
values ($1, $2, '', $3, $4)
`

type CreateSettingParams struct {
	AccountID  int64
	RelationID int64
	IsLeader   bool
	IsSelf     bool
}

func (q *Queries) CreateSetting(ctx context.Context, arg *CreateSettingParams) error {
	_, err := q.db.Exec(ctx, createSetting,
		arg.AccountID,
		arg.RelationID,
		arg.IsLeader,
		arg.IsSelf,
	)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
delete
from settings
where relation_id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, relationID int64) error {
	_, err := q.db.Exec(ctx, deleteGroup, relationID)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
delete
from settings
where account_id = $1
 and relation_id = $2
`

type DeleteSettingParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) DeleteSetting(ctx context.Context, arg *DeleteSettingParams) error {
	_, err := q.db.Exec(ctx, deleteSetting, arg.AccountID, arg.RelationID)
	return err
}

const deleteSettingsByAccountID = `-- name: DeleteSettingsByAccountID :many
delete
from settings
where account_id = $1
returning relation_id
`

func (q *Queries) DeleteSettingsByAccountID(ctx context.Context, accountID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, deleteSettingsByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var relation_id int64
		if err := rows.Scan(&relation_id); err != nil {
			return nil, err
		}
		items = append(items, relation_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const existsFriendSetting = `-- name: ExistsFriendSetting :one
select exists(select 1
              from settings s,
                   relations r
              where r.relation_type = 'friend'
                and (((r.friend_type).account1_id = $1::bigint and
                     (r.friend_type).account2_id = $2::bigint) or
                     ((r.friend_type).account1_id = $2::bigint and
                      (r.friend_type).account2_id = $1::bigint) )
                and s.account_id = $1
              )
`

type ExistsFriendSettingParams struct {
	Account1ID int64
	Account2ID int64
}

func (q *Queries) ExistsFriendSetting(ctx context.Context, arg *ExistsFriendSettingParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsFriendSetting, arg.Account1ID, arg.Account2ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsGroupLeaderByAccountIDWithLock = `-- name: ExistsGroupLeaderByAccountIDWithLock :one
select exists(select 1 from settings where account_id = $1 and is_leader = true) for update
`

func (q *Queries) ExistsGroupLeaderByAccountIDWithLock(ctx context.Context, accountID int64) (bool, error) {
	row := q.db.QueryRow(ctx, existsGroupLeaderByAccountIDWithLock, accountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsIsLeader = `-- name: ExistsIsLeader :one
select exists(select 1 from settings where relation_id = $1 and account_id = $2 and is_leader is true)
`

type ExistsIsLeaderParams struct {
	RelationID int64
	AccountID  int64
}

func (q *Queries) ExistsIsLeader(ctx context.Context, arg *ExistsIsLeaderParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsIsLeader, arg.RelationID, arg.AccountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsSetting = `-- name: ExistsSetting :one
select exists(select 1 from settings where account_id = $1 and relation_id = $2)
`

type ExistsSettingParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) ExistsSetting(ctx context.Context, arg *ExistsSettingParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsSetting, arg.AccountID, arg.RelationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAccountIDsByRelationID = `-- name: GetAccountIDsByRelationID :many
select distinct account_id
from settings
where relation_id = $1
`

func (q *Queries) GetAccountIDsByRelationID(ctx context.Context, relationID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAccountIDsByRelationID, relationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendPinSettingsOrderByPinTime = `-- name: GetFriendPinSettingsOrderByPinTime :many
select s.relation_id, s.nick_name, s.pin_time,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select settings.relation_id, settings.nick_name, settings.pin_time
      from settings,
           relations
      where settings.account_id = $1
        and settings.is_pin = true
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
    accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (account_id != $1 or is_self = true))
order by s.pin_time
`

type GetFriendPinSettingsOrderByPinTimeRow struct {
	RelationID    int64
	NickName      string
	PinTime       time.Time
	AccountID     int64
	AccountName   string
	AccountAvatar string
}

func (q *Queries) GetFriendPinSettingsOrderByPinTime(ctx context.Context, accountID int64) ([]*GetFriendPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.db.Query(ctx, getFriendPinSettingsOrderByPinTime, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendPinSettingsOrderByPinTimeRow{}
	for rows.Next() {
		var i GetFriendPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsByName = `-- name: GetFriendSettingsByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar,
       count(*) over () as total
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
             from settings,
                  relations
             where settings.account_id = $1
                and settings.relation_id = relations.id
                and relations.relation_type = 'friend') as s,
    accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (account_id != $1 or s.is_self = true))
    and ((a.name like ('%' || $4::varchar || '%')) or (nick_name like ('%' || $4::varchar || '%')))
order by a.name
limit $2 offset $3
`

type GetFriendSettingsByNameParams struct {
	AccountID int64
	Limit     int32
	Offset    int32
	Name      string
}

type GetFriendSettingsByNameRow struct {
	RelationID    int64
	NickName      string
	IsNotDisturb  bool
	IsPin         bool
	PinTime       time.Time
	IsShow        bool
	LastShow      time.Time
	IsSelf        bool
	AccountID     int64
	AccountName   string
	AccountAvatar string
	Total         int64
}

func (q *Queries) GetFriendSettingsByName(ctx context.Context, arg *GetFriendSettingsByNameParams) ([]*GetFriendSettingsByNameRow, error) {
	rows, err := q.db.Query(ctx, getFriendSettingsByName,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
		arg.Name,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendSettingsByNameRow{}
	for rows.Next() {
		var i GetFriendSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsOrderByName = `-- name: GetFriendSettingsOrderByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
             from settings,
                  relations
             where settings.account_id = $1
                and settings.relation_id = relations.id
                and relations.relation_type = 'friend') as s,
    accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (account_id != $1 or s.is_self = true))
order by a.name
`

type GetFriendSettingsOrderByNameRow struct {
	RelationID    int64
	NickName      string
	IsNotDisturb  bool
	IsPin         bool
	PinTime       time.Time
	IsShow        bool
	LastShow      time.Time
	IsSelf        bool
	AccountID     int64
	AccountName   string
	AccountAvatar string
}

func (q *Queries) GetFriendSettingsOrderByName(ctx context.Context, accountID int64) ([]*GetFriendSettingsOrderByNameRow, error) {
	rows, err := q.db.Query(ctx, getFriendSettingsOrderByName, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendSettingsOrderByNameRow{}
	for rows.Next() {
		var i GetFriendSettingsOrderByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendShowSettingsOrderByShowTime = `-- name: GetFriendShowSettingsOrderByShowTime :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = $1
        and settings.is_show = true
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
    accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (account_id != $1 or is_self = true))
order by s.last_show desc
`

type GetFriendShowSettingsOrderByShowTimeRow struct {
	RelationID    int64
	NickName      string
	IsNotDisturb  bool
	IsPin         bool
	PinTime       time.Time
	IsShow        bool
	LastShow      time.Time
	IsSelf        bool
	AccountID     int64
	AccountName   string
	AccountAvatar string
}

func (q *Queries) GetFriendShowSettingsOrderByShowTime(ctx context.Context, accountID int64) ([]*GetFriendShowSettingsOrderByShowTimeRow, error) {
	rows, err := q.db.Query(ctx, getFriendShowSettingsOrderByShowTime, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendShowSettingsOrderByShowTimeRow{}
	for rows.Next() {
		var i GetFriendShowSettingsOrderByShowTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupList = `-- name: GetGroupList :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id as relation_id,
       (r.group_type).name as group_name,
       (r.group_type).description as discription,
       (r.group_type).avatar as group_avatar,
       count(*) over () as total
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = $1
        and settings.relation_id = relations.id
        and relations.relation_type = 'group') as s,
    relations r
where r.id = (select s.relation_id from settings where relation_id = s.relation_id and (settings.account_id = $1))
order by s.last_show
`

type GetGroupListRow struct {
	RelationID   int64
	NickName     string
	IsNotDisturb bool
	IsPin        bool
	PinTime      time.Time
	IsShow       bool
	LastShow     time.Time
	IsSelf       bool
	RelationID_2 int64
	GroupName    interface{}
	Discription  interface{}
	GroupAvatar  interface{}
	Total        int64
}

func (q *Queries) GetGroupList(ctx context.Context, accountID int64) ([]*GetGroupListRow, error) {
	rows, err := q.db.Query(ctx, getGroupList, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupListRow{}
	for rows.Next() {
		var i GetGroupListRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.RelationID_2,
			&i.GroupName,
			&i.Discription,
			&i.GroupAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembers = `-- name: GetGroupMembers :many
select account_id
from settings
where relation_id = $1
`

func (q *Queries) GetGroupMembers(ctx context.Context, relationID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getGroupMembers, relationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembersByID = `-- name: GetGroupMembersByID :many
select a.id, a.name, a.avatar, s.nick_name, s.is_leader
from accounts a
    left join settings s on a.id = s.account_id
where s.relation_id = $1
limit $2 offset $3
`

type GetGroupMembersByIDParams struct {
	RelationID int64
	Limit      int32
	Offset     int32
}

type GetGroupMembersByIDRow struct {
	ID       int64
	Name     string
	Avatar   string
	NickName sql.NullString
	IsLeader sql.NullBool
}

func (q *Queries) GetGroupMembersByID(ctx context.Context, arg *GetGroupMembersByIDParams) ([]*GetGroupMembersByIDRow, error) {
	rows, err := q.db.Query(ctx, getGroupMembersByID, arg.RelationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupMembersByIDRow{}
	for rows.Next() {
		var i GetGroupMembersByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.NickName,
			&i.IsLeader,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupPinSettingsOrderByPinTime = `-- name: GetGroupPinSettingsOrderByPinTime :many
select s.relation_id,
       s.nick_name,
       s.pin_time,
       r.id,
       r.group_type
from (select settings.relation_id, settings.nick_name, settings.pin_time
      from settings,
           relations
      where settings.account_id = $1
        and settings.relation_id = relations.id
        and settings.is_pin = true
        and relation_type = 'group') as s,
    relations r
where r.id = (select relation_id from settings where relation_id = s.relation_id and account_id = $1)
order by s.pin_time
`

type GetGroupPinSettingsOrderByPinTimeRow struct {
	RelationID int64
	NickName   string
	PinTime    time.Time
	ID         int64
	GroupType  sql.NullString
}

func (q *Queries) GetGroupPinSettingsOrderByPinTime(ctx context.Context, accountID int64) ([]*GetGroupPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.db.Query(ctx, getGroupPinSettingsOrderByPinTime, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupPinSettingsOrderByPinTimeRow{}
	for rows.Next() {
		var i GetGroupPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.ID,
			&i.GroupType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupSettingsByName = `-- name: GetGroupSettingsByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id as relation_id,
       (r.group_type).name as group_name,
       (r.group_type).avatar as group_avatar,
       (r.group_type).description as description,
       count(*) over () as total
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
          from settings,
               relations
          where settings.account_id = $1
            and settings.relation_id = relations.id
            and relations.relation_type = 'group') as s,
    relations r
where r.id = (select s.relation_id from settings where relation_id = s.relation_id and (settings.account_id = $1))
    and (((r.group_type).name like ('%' || $4::varchar || '%')))
order by (r.group_type).name
limit $2 offset $3
`

type GetGroupSettingsByNameParams struct {
	AccountID int64
	Limit     int32
	Offset    int32
	Name      string
}

type GetGroupSettingsByNameRow struct {
	RelationID   int64
	NickName     string
	IsNotDisturb bool
	IsPin        bool
	PinTime      time.Time
	IsShow       bool
	LastShow     time.Time
	IsSelf       bool
	RelationID_2 int64
	GroupName    interface{}
	GroupAvatar  interface{}
	Description  interface{}
	Total        int64
}

func (q *Queries) GetGroupSettingsByName(ctx context.Context, arg *GetGroupSettingsByNameParams) ([]*GetGroupSettingsByNameRow, error) {
	rows, err := q.db.Query(ctx, getGroupSettingsByName,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
		arg.Name,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupSettingsByNameRow{}
	for rows.Next() {
		var i GetGroupSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.RelationID_2,
			&i.GroupName,
			&i.GroupAvatar,
			&i.Description,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupShowSettingsOrderByShowTime = `-- name: GetGroupShowSettingsOrderByShowTime :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id,
       r.group_type
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
             from settings,
                  relations
             where settings.account_id = $1
                and settings.relation_id = relations.id
                and settings.is_show = true
                and relations.relation_type = 'group') as s,
    relations r
where r.id = (select relation_id from settings where relation_id = s.relation_id and account_id = $1)
order by s.last_show desc
`

type GetGroupShowSettingsOrderByShowTimeRow struct {
	RelationID   int64
	NickName     string
	IsNotDisturb bool
	IsPin        bool
	PinTime      time.Time
	IsShow       bool
	LastShow     time.Time
	IsSelf       bool
	ID           int64
	GroupType    sql.NullString
}

func (q *Queries) GetGroupShowSettingsOrderByShowTime(ctx context.Context, accountID int64) ([]*GetGroupShowSettingsOrderByShowTimeRow, error) {
	rows, err := q.db.Query(ctx, getGroupShowSettingsOrderByShowTime, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupShowSettingsOrderByShowTimeRow{}
	for rows.Next() {
		var i GetGroupShowSettingsOrderByShowTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.ID,
			&i.GroupType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByID = `-- name: GetSettingByID :one
select account_id, relation_id, nick_name, is_not_disturb, is_pin, pin_time, is_show, last_show, is_leader, is_self
from settings
where account_id = $1
    and relation_id = $2
`

type GetSettingByIDParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) GetSettingByID(ctx context.Context, arg *GetSettingByIDParams) (*Setting, error) {
	row := q.db.QueryRow(ctx, getSettingByID, arg.AccountID, arg.RelationID)
	var i Setting
	err := row.Scan(
		&i.AccountID,
		&i.RelationID,
		&i.NickName,
		&i.IsNotDisturb,
		&i.IsPin,
		&i.PinTime,
		&i.IsShow,
		&i.LastShow,
		&i.IsLeader,
		&i.IsSelf,
	)
	return &i, err
}

const transferIsLeaderFalse = `-- name: TransferIsLeaderFalse :exec
update settings
set is_leader = false
where relation_id = $1
    and account_id = $2
`

type TransferIsLeaderFalseParams struct {
	RelationID int64
	AccountID  int64
}

func (q *Queries) TransferIsLeaderFalse(ctx context.Context, arg *TransferIsLeaderFalseParams) error {
	_, err := q.db.Exec(ctx, transferIsLeaderFalse, arg.RelationID, arg.AccountID)
	return err
}

const transferIsLeaderTrue = `-- name: TransferIsLeaderTrue :exec
update settings
set is_leader = true
where relation_id = $1
    and account_id = $2
`

type TransferIsLeaderTrueParams struct {
	RelationID int64
	AccountID  int64
}

func (q *Queries) TransferIsLeaderTrue(ctx context.Context, arg *TransferIsLeaderTrueParams) error {
	_, err := q.db.Exec(ctx, transferIsLeaderTrue, arg.RelationID, arg.AccountID)
	return err
}

const updateSettingDisturb = `-- name: UpdateSettingDisturb :exec
update settings
set is_not_disturb = $1
where account_id = $2
    and relation_id = $3
`

type UpdateSettingDisturbParams struct {
	IsNotDisturb bool
	AccountID    int64
	RelationID   int64
}

func (q *Queries) UpdateSettingDisturb(ctx context.Context, arg *UpdateSettingDisturbParams) error {
	_, err := q.db.Exec(ctx, updateSettingDisturb, arg.IsNotDisturb, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingLeader = `-- name: UpdateSettingLeader :exec
update settings
set is_leader = $1
where account_id = $2
    and relation_id = $3
`

type UpdateSettingLeaderParams struct {
	IsLeader   bool
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingLeader(ctx context.Context, arg *UpdateSettingLeaderParams) error {
	_, err := q.db.Exec(ctx, updateSettingLeader, arg.IsLeader, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingNickName = `-- name: UpdateSettingNickName :exec
update settings
set nick_name = $1
where account_id = $2
 and relation_id = $3
`

type UpdateSettingNickNameParams struct {
	NickName   string
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingNickName(ctx context.Context, arg *UpdateSettingNickNameParams) error {
	_, err := q.db.Exec(ctx, updateSettingNickName, arg.NickName, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingPin = `-- name: UpdateSettingPin :exec
update settings
set is_pin = $1
where account_id = $2
    and relation_id = $3
`

type UpdateSettingPinParams struct {
	IsPin      bool
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingPin(ctx context.Context, arg *UpdateSettingPinParams) error {
	_, err := q.db.Exec(ctx, updateSettingPin, arg.IsPin, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingShow = `-- name: UpdateSettingShow :exec
update settings
set is_show = $1
where account_id = $2
    and relation_id = $3
`

type UpdateSettingShowParams struct {
	IsShow     bool
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingShow(ctx context.Context, arg *UpdateSettingShowParams) error {
	_, err := q.db.Exec(ctx, updateSettingShow, arg.IsShow, arg.AccountID, arg.RelationID)
	return err
}
